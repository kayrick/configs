#!/usr/bin/env perl

use Time::Piece;
use Time::Local;
use Term::ANSIColor qw(:constants);
use Getopt::Std;

my $fname;
my %options;

$ok = getopts('uq', \%options);

my $quiet = $options{q};
my $update = $options{u};

my ($day, $month, $year) = (localtime())[3,4,5];
my $today = timelocal(0,0,0,$day,$month,$year);

my @tasks;

sub print_or_store
{
  my $str = $_[0];
  return if ($str =~ m/^x/);
  if ($str =~ m/due:(\d{4})-(\d{2}).(\d{2})/) {
    my $due = timelocal(0,0,0,$3,$2 - 1,$1 - 1900);
    if ($due == $today) {
      print BOLD, $_, RESET;
    } else {
      push @tasks, [$due, $_];
    }
  }
}

sub preserve
{
  return $_[0];
}

sub update_due
{
}

my %handlers = (
  Weekly 
)

sub process_tag
{
  switch ($_[1]) {
  }
  return $_[0]
}

sub update
{
  my $str = $_[0];
  my $FILE = $_[1];
  if ($str =~ m/^x/)
  {
    foreach ($str =~ /\@([\w_0-9]+)/g)
    {
      my $tmp = process_tag $str, $_
      print $FILE $tmp if ($tmp);
    }
  } else {
    print $FILE $str;
  }
}

sub walk_file
{
  my $FILE;
  my $UFILE;
  my $fname = $_[0];

  if ($fname eq "-") {
    $FILE = *STDIN;
    $UFILE = *STDOUT if ($update)
  } else {
    open $FILE, $fname or die $!;
    open $UFILE, ">$fname.upd" if ($update)
  }

  while(<$FILE>) {
    print_or_store $_ if (not $quiet);
    update $_, $UFILE if ($update);
  }
}

sub print_tasks{
  my @sorted = sort {$a->[0] <=> $b->[0]} @tasks;

  for my $idx (0 .. $#sorted) {
    if ($sorted[$idx][0] < $today) {
      print RED, $sorted[$idx][1], RESET;
    } else {
      print GREEN, $sorted[$idx][1], RESET;
    }
  }
}

if (@ARGV == 0) {
  walk_file $ENV{'HOME'} . "/Documents/TODO/Todo.txt";
} else {
  foreach (@ARGV) {
    walk_file $_;
  }
}

print_tasks if (not $quiet);
