#!/usr/bin/env perl

use Time::Piece;
use Time::Local;
use Term::ANSIColor qw(:constants);
use Getopt::Std;
use DateTime;

my $fname;
my %options;

$ok = getopts('uqh', \%options);

my $quiet = $options{q};
my $update = $options{u};
my $human = $options{h};

my $today = DateTime->today();

my @tasks;

sub get_due_date
{
  if ($_[0] =~ m/due:(\d{4})-(\d{2})-(\d{2})/) {
    return DateTime->new (year=>$1, month => $2, day => $3);
  } else {
    return undef;
  }
}

sub update_date
{
  my $date = $_[1]->strftime('%Y-%m-%d');
  $_[0] =~ s/due:\d{4}-\d{2}-\d{2}/due:$date/;
}

sub print_or_store
{
  return if ($quiet);
  my $str = $_[0];
  return if ($str =~ m/^x/);
  my $due = get_due_date $str;
  return if (not defined $due);
  if ($due == $today) {
    if ($human) {
      print BOLD, "Today\n", RESET;
      $human = false;
    }
    print BOLD, $str, RESET;
  } else {
    push @tasks, [$due, $str];
  }
}

sub preserve
{
  return $_[0];
}

sub reset_task
{
  $_[0] =~ s/^x/(B)/;
}

sub reset_and_postpone_days
{
  my $task = $_[0];
  my $due = get_due_date $task;
  $due = $today if (not defined $due);
  my $new_due = $due->add (days => $_[1]);
  reset_task $task;
  update_date $task, $new_due;
  return $task;
}

sub reset_and_postpone_months
{
  my $task = $_[0];
  my $due = get_due_date $task;
  $due = $today if (not defined $due);
  my $new_due = $due->add (months => $_[1]);
  reset_task $task;
  update_date $task, $new_due;
  return $task;
}

my %handlers = (
  "Daily" => sub {reset_and_postpone_days $_[0], 1},
  "Weekly" => sub {reset_and_postpone_days $_[0], 7},
  "Monthly" => sub {reset_and_postpone_months $_[0], 1},
  "2Monthly" => sub {reset_and_postpone_months $_[0], 2}
);

sub process_tag
{
  return $handlers{$_[1]}->($_[0]) if exists ($handlers{$_[1]});
  return "";
}

sub update
{
  my $str = $_[0];
  my $FILE = $_[1];
  if ($str =~ m/^x/)
  {
    foreach ($str =~ /\@([\w_0-9]+)/g)
    {
      my $tmp = process_tag $str, $_;
      if ($tmp) {
        print $FILE $tmp;
        print_or_store $tmp;
      }
    }
  } else {
    print $FILE $str;
  }
}

sub walk_file
{
  my $FILE;
  my $UFILE;
  my $fname = $_[0];
  my $buffer;

  if ($fname eq "-") {
    $FILE = *STDIN;
    $UFILE = *STDOUT if ($update);
  } else {
    open $FILE, $fname or die $!;
    $buffer = "$fname.upd";
    open $UFILE, ">$buffer" if ($update);
  }

  while(<$FILE>) {
    update $_, $UFILE if ($update);
    print_or_store $_;
  }
  rename $buffer, $fname if (defined $buffer);
}

sub print_tasks{
  my @sorted = sort {$a->[0] <=> $b->[0]} @tasks;

  for my $idx (0 .. $#sorted) {
    if ($sorted[$idx][0] < $today) {
      print RED, $sorted[$idx][1], RESET;
    } else {
      print GREEN, $sorted[$idx][1], RESET;
    }
  }
}

if (@ARGV == 0) {
  walk_file $ENV{'HOME'} . "/Documents/TODO/Todo.txt";
} else {
  foreach (@ARGV) {
    walk_file $_;
  }
}

print_tasks if (not $quiet);
