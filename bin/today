#!/usr/bin/env perl

use Time::Piece;
use Time::Local;
use Term::ANSIColor qw(:constants);
use Getopt::Std;

my $fname;
my %options;

$ok = getopts('uq', \%options);

my $quiet = $options{q};
my $update = $options{u};

my ($day, $month, $year) = (localtime())[3,4,5];
my $today = timelocal(0,0,0,$day,$month,$year);

my @tasks;

sub get_due_date
{
  if ($_[0] =~ m/due:(\d{4})-(\d{2}).(\d{2})/) {
    return timelocal(0,0,0,$3,$2 - 1,$1 - 1900);
  } else {
    return "";
  }
}

sub print_or_store
{
  my $str = $_[0];
  return if ($str =~ m/^x/);
  my $due = get_due_date $str;
  return if (not $due);
  if ($due == $today) {
    print BOLD, $_, RESET;
  } else {
    push @tasks, [$due, $_];
  }
}

sub preserve
{
  return $_[0];
}

sub reset_task
{
  $_[0] =~ s/^x/(B)/;
}

sub reset_and_postpone_days
{
  my $task = $_[0];
  my $due = get_due_date $task;
  $due = $today is (not $due);

  reset_task $task;
  return $task;
}

sub reset_and_postpone_months
{
  reset_task $_[0];
  return $_[0];
}

my %handlers = (
  "Weekly" => sub {reset_and_postpone_days $_[0], 7},
  "Monthly" => sub {reset_and_postpone_months $_[0], 1},
  "2Monthly" => sub {reset_and_postpone_months $_[0], 2}
);

sub process_tag
{
  return $handlers{$_[1]}->($_[0]) if exists ($handlers{$_[1]});
  return "";
}

sub update
{
  my $str = $_[0];
  my $FILE = $_[1];
  if ($str =~ m/^x/)
  {
    foreach ($str =~ /\@([\w_0-9]+)/g)
    {
      my $tmp = process_tag $str, $_;
      print $FILE $tmp if ($tmp);
    }
  } else {
    print $FILE $str;
  }
}

sub walk_file
{
  my $FILE;
  my $UFILE;
  my $fname = $_[0];

  if ($fname eq "-") {
    $FILE = *STDIN;
    $UFILE = *STDOUT if ($update)
  } else {
    open $FILE, $fname or die $!;
    open $UFILE, ">$fname.upd" if ($update)
  }

  while(<$FILE>) {
    print_or_store $_ if (not $quiet);
    update $_, $UFILE if ($update);
  }
}

sub print_tasks{
  my @sorted = sort {$a->[0] <=> $b->[0]} @tasks;

  for my $idx (0 .. $#sorted) {
    if ($sorted[$idx][0] < $today) {
      print RED, $sorted[$idx][1], RESET;
    } else {
      print GREEN, $sorted[$idx][1], RESET;
    }
  }
}

if (@ARGV == 0) {
  walk_file $ENV{'HOME'} . "/Documents/TODO/Todo.txt";
} else {
  foreach (@ARGV) {
    walk_file $_;
  }
}

print_tasks if (not $quiet);
