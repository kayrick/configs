#!/usr/bin/env perl

use Time::Piece;
use Time::Local;
use Term::ANSIColor qw(:constants);
use Getopt::Std;
use DateTime;

my $fname;
my %options;

$ok = getopts('uqh', \%options);

my $quiet = $options{q};
my $update = $options{u};
my $human = $options{h};

my $today_printed = 0;
my $tomorow_printed = 0;
my $within_week_printed = 0;
my $after_week_printed = 0;

my $today = DateTime->today();

my @tasks;

sub get_due_date
{
  if ($_[0] =~ m/due:(\d{4})-(\d{2})-(\d{2})/) {
    return DateTime->new (year=>$1, month => $2, day => $3);
  } else {
    return undef;
  }
}

sub update_date
{
  my $date = $_[1]->strftime('%Y-%m-%d');
  $_[0] =~ s/due:\d{4}-\d{2}-\d{2}/due:$date/;
}

sub print_or_store
{
  return if ($quiet);
  my $str = $_[0];
  return if ($str =~ m/^x/);
  my $due = get_due_date $str;
  return if (not defined $due);
  if ($due == $today) {
    if ($human and not $today_printed) {
      print BOLD, "Today\n", RESET;
      $today_printed = 1;
    }
    print BOLD, $str, RESET;
  } else {
    push @tasks, [$due, $str];
  }
}

sub reset_task
{
  $_[0] =~ s/^x *//;
}

my %unit_map = (d => "days", m => "months", w => "weeks", y => "years");

sub process_rec
{
  my $val = $_[1];
  my $units =  $_[2];
  my $task = $_[0];
  my $due = get_due_date $task;
  $due = $today if (not defined $due);
  my $new_due = $due->add ($unit_map{$units} => $val);
  reset_task $task;
  update_date $task, $new_due;
  return $task;
}

sub update
{
  my $str = $_[0];
  my $FILE = $_[1];
  if ($str =~ m/^x.*rec:([0-9]+)([dwmy])/)
  {
    my $tmp = process_rec $str, $1, $2;
    if ($tmp) {
      print $FILE $tmp;
      print_or_store $tmp;
    }
  } else {
    print $FILE $str;
  }
}

sub walk_file
{
  my $FILE;
  my $UFILE;
  my $fname = $_[0];
  my $buffer;

  if ($fname eq "-") {
    $FILE = *STDIN;
    $UFILE = *STDOUT if ($update);
  } else {
    open $FILE, $fname or die $!;
    $buffer = "$fname.upd";
    open $UFILE, ">$buffer" if ($update);
  }

  while(<$FILE>) {
    update $_, $UFILE if ($update);
    print_or_store $_;
  }
  rename $buffer, $fname if (defined $buffer);
}

sub print_fancy
{
  my $diff = $_[0];
  if ($diff == 1 and $tomorow_printed == 0) {
    $tomorow_printed = 1;
    print BOLD, "Tomorrow\n", RESET;
    return;
  }
  if ($diff > 1 and $diff <= 7 and $within_week_printed == 0) {
    $within_week_printed = 1;
    print BOLD, "Within a week\n", RESET;
    return;
  } 
  if ($diff > 7 and $after_week_printed == 0) {
    $after_week_printed = 1;
    print BOLD, "Later\n", RESET;
    return;
  } 
}

sub print_tasks{
  my @sorted = sort {$a->[0] <=> $b->[0]} @tasks;
  for my $idx (0 .. $#sorted) {
    my $curr = $sorted[$idx][1];
    my $due = $sorted[$idx][0];
    if ($due < $today) {
      print RED, $curr, RESET;
    } else {
      if ($human) {
        print_fancy ($due->delta_days($today)->in_units('days'));
      }
      print GREEN, $curr, RESET;
    }
  }
}

if (@ARGV == 0) {
  walk_file $ENV{'HOME'} . "/Documents/TODO/Todo.txt";
} else {
  foreach (@ARGV) {
    walk_file $_;
  }
}

print_tasks if (not $quiet);
